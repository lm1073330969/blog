# 面试常见的面试题
## 1.基本类型和复杂类型相关的面试题

### Q1：基本类型有哪几种？
基本类型有六种，分别是：undefined、null、number、string、boolearn、symbol（ES6新增的）

### Q2：undefined和null的比较和区别？
- undefined  

undefined类型具有唯一的值，即undefined，当声明变量未初始化的时候，该变量的默认值为undefined。 

```
var test;
alert(typeof test);     //'undefined'
```

> 提示：值undefined并不等同于未定义的值，typeof并不能区分以下两种情况  

```
var test1;

alert(typeof test1);    //"undefined"
alert(typeof test2);    //"undefined"
```

以上两种情况都会输出undefined，但是test1是已经声明没有复制，默认的值为undefined，但是后者从未进行过声明，要注意这一点，并且对于test2只能进行typeof操作，进行其他的运算会出错，下面的代码会引发错误：

```
alert(test2 == undefined);  //报错，因为test2没有进行过声明，所以除了typeof不能进行其他的操作
alert(typeof test2== 'undefined');  //true
```

- null

它有唯一专用值null，值undefined实际上是从null派生来的

```
alert(undefined == null);   //true
```

- 区别

尽管这两个值在相等，但是他们的含义不同。  
undefined是表示对已经声明之后变量，但为进行初始化的变量给定的一个默认值。  
null则用于表示空的或者是尚未存在的对象。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是null。  
所以二者之间的区别就是已经声明并且定义了，可定义了的值为null的情况，一般用于初始化对象的赋值，另一种就是声明了但是为定义是何种类型的。

```
var test;   //undefined
var box = null;     //null
```

### Q3：null是对象吗？
虽然typeof null返回的是object，但是null不是对象，而是基本数据类型的一种。

### Q4：为什么null返回的是object？
因为在js最初版本中，使用的是32位系统，为了性能考虑使用低位存储了变量的类型信息，000开头代表的是对象，然而null表示为全0，所以他错误的判断为object，虽然现在的内部类型判断代码已经改变不了，但是对于这个bug却是一直流下来了。  
现在null被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，他仍然是原始值。  

### Q5：基本数据类型和复杂数据类型存储有什么区别？
- 基本数据类型是存放在栈内存中的。

> 假如有以下几个基本类型的变量：  

```
var name = 'jozo';
var city = 'guanzhou';
var age = 22;
```

> 存储结构如图所示：  

![EXF4YQ.png](https://s2.ax1x.com/2019/05/18/EXF4YQ.png)

- 引用数据类型同时保存在堆内存和栈内存中  

引用类型的存储是需要栈内存和堆内存共同完成的，栈内存中保存变量标识符和指向堆内存的地址，堆内存中保存的是引用类型的值

```
var person1 = {name: 'change1'};
var person2 = {name: 'change2'};
var person3 = {name: 'change3'};
```

三个对象在内存中的存储情况如图：

![EXR7gx.png](https://s2.ax1x.com/2019/05/19/EXR7gx.png)

### Q6：基本数据类型和引用类型有什么区别？

- 基本数据类型

1.基本数据类型的值是不可以改变的

> 任何方法都无法改变一个基本类型的值，比如一个字符串：

```
var s = 'hello';
s.toUpperCase();    //HELLO
console.log(s);     //hello
```
通过上面的代码可以看出s的值始终没有变化，调用toUpperCase()方法，返回的是一个新的字符串，并没有改变s里面存储的值，和原来定义的变量没有任何关系。

> 还有这样的一个例子：

```
var name = 'hello';
name = 'word';
console.log(name);      //word
```
这个例子看起来像是改变了基本变量name的值，但是上面不是说了吗，基本类型里面的值是不可改变的，为什么这个name的值改变了呢？其实这里的改变并不是表面上看起来的那样值改变了，而是指针的指向改变了，所以基本数据类型的值是不可改变的是对的。

现在剖析一下这个例子，name一开始指向的是存储hello的内存，但是后来改变了name的指针指向，这个过程并没有对值进行操作。

注意：也就是说你可以这样认为，基本变量改变的只是“指针的指向的改变”

2.基本数据类型不可以添加属性和方法  

3.基本数据类型的赋值是相互独立的

如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。

```
var a = 10;
var b = a;
a++;
console.log(a);     //11
console.log(b);     //10
```

上面的代码中，a保存的值是10，当用a来初始化b时，b中也保存了a的值10，但是，需要注意的是a中的10和b中的10是相互独立的，上面代码操作了，改变的也只有a的值，b并没有受影响，因为他们的赋值是会将值也复制一份，所有不同变量之间就算值相同，进行操作也不会有影响。如下图：

![EXRKBD.png](https://s2.ax1x.com/2019/05/19/EXRKBD.png)

4.基本数据类型的比较的是值

```
var a = '{}';
var b = '{}';
console.log(a == b)     //true
console.log(a === b)    //true
```

5.基本数据类型存在栈区

- 引用类型

1.引用类型的值是可以改变的

2.引用类型可以添加属性和方法

3.引用类型的赋值是对象引用，会相互影响

当从一个变量向另一个变量赋值引用类型的值时，同样也会将存储在变量中的值复制一份放到新变量分配的存储空间中，但是关键是引用类型保存在变量中的是对象在堆内存中的地址，所以，与基本数据类型的简单赋值不同，这个值的实际上是一个指针，这个指针指向的是存储在堆内存的对象，这才是真正存值的地方，那么赋值之后，两个变量都保存的是同一个对象的地址，而这两个地址指向的是同一个对象，改变其中任何一个变量，都会互相影响。

> 有以下引用类型的赋值操作：  

```
var a = {};
var b = a;
```

> 赋值，如图所示：

![EXArrt.png](https://s2.ax1x.com/2019/05/18/EXArrt.png)

4.引用类型的比较是对地址的比较

```
var person1 = {};
var person2 = {};

console.log(person1 == person2);    //false
```
引用类型的比较是比较两个引用类型在栈内存中存储的指向堆内存中的指针是否相同。

上面的代码，person1是一个引用类型，在堆内存中开辟了一块空间，此时person1在栈内存中存储了一个地址，person2同样是引用类型，定义之后同样会在堆内存中开辟一块空间，person2的栈内存同样存储着一块地址，但是这两块地址不同，所以比较是false。

5.引用类型是同时存储在栈内存和堆内存中的。

在栈内存中存储的是变量和指向堆内存的地址  
堆内存中存在的是真正的引用类型的保存的值

### Q7：与事件委托相关的面试题

**题目：怎么为1000个元素添加点击事件，怎么确定其中的某一个？**

思路：首先回答这道题的关键就是事件委托，先要说明什么是事件委托。

事件委托就是把事件比如click事件交给别人来做，事件委托的原理是利用事件冒泡，把事件添加到父级，这样就可以实现用一个事件处理程序，管理某一个类型的所有事件。

比如一个列表，我们需要在每一个li上面都添加一个click事件，如果在大量的情况下就可以使用委托事件，不需要在每一个li上面都绑定事件处理程序，只在他的父级ul上面添加一个绑定事件即可。这样点击li，利用冒泡直接出发ul的click，如果想要知道具体是哪一个，只需要获取他的id即可，用event.target.id

一般我们能用到的target对象里面的属性也就是：id、innerHTML、nodeName、innerText



