### TCP协议和UDP协议的区别是什么？

1. TCP协议是有连接的，需要在开始传世数据之前进行三次握手，会话结束也要四次挥手来结束会话，而UDP协议是面向无连接的
2. TCP协议保证数据按顺序发送，按顺序到达，提供超时重传来帮正可靠性，而UDP是具有不可靠性，他对数据不保证到达顺序，甚至不保证能到达，只是努力交付，即便是按顺序发送的序列也不能保证按顺序到达
3. TCP协议所需资源多，TCP首部需要20多字节，但是UDP只需要8字节
4. TCP有流量控制和拥塞控制，UDP没有，在网络拥堵的情况下不会影响发送端的发送速率
5. TCP是一对一连接，而UDP可以支持一对一、一对多、多对一、多对多的通信
6. TCP面向的是字节流的服务，UDP面向的是报文的服务

### UDP使用的常用

UDP虽然对比TCP有很多缺点，但是正是因为这些缺点造就了他高效的特性，在很多时效性要求高的地方都可以看到UDP的身影

比如：视频、直播、游戏等方面

### TCP

#### 头部

对于TCP头部来说，以下几个字段是很重要的：

Seq：这个序号保证了TCP传输的报文都是有序的，对端可以通过序号顺序的拼接报文

ACK：这个序号表示数据接收端期望接受的下一个字节的编号是多少，同时也代表上一个序号的数据已经收到

SYN = 1：当SYN=1、ACK=0的时候，表示当前报文段是一个连接请求报文。当SYN=1、ACK=1的时候，表示当前报文段是一个同意建立连接的应答报文

FIN：表示此报文段是一个释放连接的请求报文

#### 三次握手

首先假设主动发起请求的一端称为客户端，被连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完成后都能发送接收数据，所以TCP是一个全双工的协议

![nljkSs.png](https://s2.ax1x.com/2019/09/07/nljkSs.png)

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段中包含自身数据通讯初始序号，请求发送后，客户端进入了SYN-SENT状态

**第二次握手**

服务端收到连接请求报文后，如果同意连接，则会发送一个应答，，该应答中也会包含自身的数据通讯初始序号 ，发送完成后便进入SYN-RECEIVED阶段。

**第三次握手**

当可短收到连接同意的应答后，还要向服务端发送一个确认报文，客户端发送完这个报文段后便进入了TCP连接成功的状态，服务端收到这个确认报文后也进入了TCP连接成功的状态，此时连接建立成功

三次握手的必要性就是要保证建立连接的双方保证彼此都能正常发送信息以及一次请求发送

#### 面试题：为什么TCP建立连接需要三次握手，两次和四次为什么不可以？

**两次握手**：

第一次握手就是客户端发送了请求连接，第二次服务端同意了连接的请求，但是这时就结束我握手了，然而服务端不知道客户端是否已经接受到了应答

基于这种情况，就会有一种可能性发生，就是第一次握手客户端发送了连接请求A，但是因为网络的原因导致了超时，这是就会再次发送请求连接B，B正常到达服务端，服务端应答就建立了连接，然后接收完数据之后就释放了连接

假设这时连接请求A在上面一次连接完成关闭之后到达了服务端，那么此时服务端会认为是客户端又一次发送了连接请求，从而应答了请求，但是此时客户端是关闭状态的，那么就会导致服务端一直等待，造成资源浪费

PS：在建立连接的过程中，任意一端掉线，TCP都会重发SYN包，一般重试5次

**四次握手**

三次握手已经保证了双方的正常连接发送数据了，每多一次握手就会造成一次资源的浪费

#### 面试题：SYN攻击

SYN攻击是指攻击在客户端，在短时间内伪造大量不存在的IP地址，向服务器不断发送SYN包，服务器回复确认包后，并等待客户端的确认，但是由于原地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间的占用连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重会引起网络堵塞甚至系统瘫痪

**如何防御SYN攻击**

SYN攻击不能被完全的阻止，除非将TCP协议重新设计。我们所做的也就是尽可能减少SYN攻击的危害，常见的防御SYN攻击的方法有如下几种：

- 缩短超时时间
- 过滤网关防护
- SYN cookies技术

#### 四次挥手

![n1pfQH.png](https://s2.ax1x.com/2019/09/07/n1pfQH.png)

TCP是全双工的，在断开连接时两段都需要发送FIN和ACK

**第一次挥手**

主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动告诉被动关闭方：我已经发送完了我所有的数据，但是此时主动关闭方还可以接受数据

**第二次挥手**

被动关闭方收到FIN饱之后，发送一个ACK给对方，但是因为是双向的，所以被关闭方依旧可以发送数据给主动关闭方

**第三次挥手**

被动关闭方发送了一个FIN包，用来被动关闭方到主动关闭方的数据传送，也就是告诉主关闭方，我的数据也发送完了，不会再给你发送数据了

**第四次挥手**

主动关闭方收到FIN后，发送一个ACK给被动关闭方

#### 保证可靠传输的原因是什么？

**超时重传机制**

发送方发送的报文中含有序列号，每当发送一个报文后就会启动一个计时器，该计时器的时间一般由当前网络来决定，一个RTT是指当一个报文从发送都接收到对应的ACK标志的时间。RTO的决定一般是发送方尝试发送几个报文，然后去平均RTT时间来决定计时器的值，当发送一个报文以后，发送发在计时范围内没有收到相应的ACK确认报文，那么发送方就会重传该报文

**快速重传机制**

该机制是指，发送方一直发送报文，不会每发送一次报文都等待对应的ACK确认标志才发送下一个报文，当接收方发现接受的序号不对的时候，会连续发送三个ACK标志，告诉对方，这个报文在传输过程中丢包了，发送方如果接收到某个相同序列号的三个 ACK 报文，那么此时立马重发该报文，不用等待计时器的时间结束。

### OSI七层模型

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 无力撑