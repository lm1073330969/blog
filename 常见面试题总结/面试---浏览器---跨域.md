> 涉及面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求吗？

因为浏览器出于安全考虑，有同源策略，也就是说，如果协议、域名、端口三者之中有一个不同就是跨域。

**那么是出于什么安全考虑才会引入这种机制呢？**

其实主要是用来防止CSRF攻击的。简单点说，CSRF攻击是利用用户的登录态发起恶意请求的。

也就是说，如果没有同源策略的情况下，A网站可以被任意其他来源的ajax访问到内容。如果你当前A网站还存在登录态，那么对方就可以通过ajax获取你的任何信息。当然跨域并不能完全阻止CSRF

**然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？**

答案是请求必然发出去了，但是浏览器拦截了响应。因为跨域是为了阻止用户读取到另一个域名下的内容，ajax可以获取响应，但是浏览器认为这是不安全的，所以拦截了响应。同时也说明了跨域不能完全阻止CSRF，因为请求毕竟是发出去了

### JSONP

JSONP的原理很简单，就是利用script标签没有跨域限制的漏洞，通过script标签指向一个需要访问的地址并可以提供一个回调函数来接收数据。

JSONP使用简单且兼容性不错，但是只限于get请求。

### CORS

CORS需要浏览器和后端同时支持，IE8和9需要通过XDomainRequest来实现。

浏览器会自动进行CORS通信，实现CORS通信的关键是后端。只要后端实现了CORS，就实现了跨域。

虽然设置CORS和前端没有什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和非简单请求。

**简单请求**

只要同时满足以下两大条件，就属于简单请求：

（1）请求方法是以下三种方法之一：

- HEAD
- GET
- POST

（2）HTTP的头信息不能超出以下字段：

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type（值只能是text/plain/multipart/form-data/application/x-www-form-urlencoded）

凡是不能同时满足上述两个条件的就属于非简单请求。

CORS的简单请求不会触发**预检请求**

**非简单请求**

对于非简单请求来说，首先会发起一个预检请求，该请求是option方法，通过该请求来知道服务端是否允许跨域请求。

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT和DELETE或者Content-Type字段类型是application/json。

浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用那些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

**CORS和JSONP对比**

- JSONP只能实现get请求，而CORS支持所有类型的HTTP请求
- JSONP主要被老的浏览器支持，他们往往不支持CORS，而绝大多数现代浏览器已经支持CORS了

CORS与JSONP相比，无疑更为先进、方便和可靠。

### document.domain

该方式只能用于**二级域名相同**的情况下，比如a.test.com和b.test.com适用于该方式。

只要给页面添加document.domain='test.com'表示二级域名都相同就可以实现跨域

通常用在两个iframe之间。

问题：

- 安全性，当一个站点被攻击后，另一个站点会引起安全漏洞
- 如果一个页面引入多个iframe，要想操作所有iframe，必须都得设置相同的domain

### HTML5的postMessage方法

这种方式通常用于获取嵌入页面中的第三方页面数据，一个页面发送消息，一个页面判断来源并接收消息。说白了就是，在test1.com域的页面A中通过iframe嵌入了一个test2.com域的B页面，就可以通过这种方式进行A、B页面之间的通讯。

这个功能主要包括接受信息的message事件和发送消息的postMessage方法。

postMessage(message, targetOrigin)

- message: 是要发送的消息，类型为 String、Object (IE8、9 不支持)
- targetOrigin: 是限定消息接收范围，不限制请使用 '*

```js
    //发送消息端
    window.parent.postMessage('hello', 'http://test.com');

    //接收消息端
    mc.addEventListener('message', event => {
      let origin = event.origin;
      if(origin === 'http://test.com') {
        console.log('验证通过');
      }
    })
```

### 优化WEB性能之减少预检请求

**从某一角度讲跨域请求是不可避免的，但是如果跨域请求有1000个，那么是不是要有对应的1000个预检请求？如何尽可能减少options请求以优化性能？**

首先，从目前的项目中得到的经验来看，想要避免跨域是不可能的，那么options请求可以减少吗？

从之前的“简单请求”可以知道，当一个跨域请求符合浏览器认为的安全跨域请求情况下，虽然跨域仍然存在，但是options请求不会发送了，那么我们就可以把“复杂请求”转化为“简单请求”吗？

答案是：**NO**

首先就是请求的方法，现在开发都遵循规范来开发，并且put和delete方法的必要性是不可否认的，如果去掉了这两个方法，回赠加很多交流上的成本问题。

其次就是Headers，现在我们大多数使用json和后台进行交互的，但是Content-Type中的三个值没有application/json。不仅如此，为了安全问题，我们在请求的时候，往往会在header里增加一个自定义字段token，用于用户身份校验。这个字段也是不可省略的。

所以，从方法到Header都不允许我们把请求从“复杂请求”变成“简单请求”，所以，应该有的OPTION请求是不能被忽略的。

但是在实际应用中，web应该经常会遇到刷新操作，这时候同样的接口也要发送option请求，那么这些重复的跨域请求是可以避免的吗？

答案是：**YES**

可以看到在预检请求响应头部有一个Access-Control-Max-Age,在这个有效时间内，同一请求无需在发送option请求。所以可以利用这个请求头，来减少option的发送。

另外需要注意的是，同一请求指的是整个请求从 URL 到方法到 Header 到参数到数据，都要完全一致，才会认为这是同一请求，所以，即便只是增加了一个参数或者修改了一个参数值，仍旧不能避免OPTIONS的发送。