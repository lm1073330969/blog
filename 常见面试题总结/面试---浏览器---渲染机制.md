### 关键渲染路径

提到页面渲染，有几个相关度非常高的概念，最重要的是关键渲染路径，其他几个概念都可以从他展开。

**关键渲染路径：** 是指与当前用户操作有关的内容，例如用户刚刚打开一个界面，首屏的显示就是当前用户要操作的内容，具体就是浏览器收到HTML、CSS、JavaScript等资源并对其进行处理从而渲染出web界面。

了解浏览器渲染过程与原理，很大程度上是为了**优化关键渲染路径**，但优化应该是针对具体的问题的解决方案，所以优化没有一定之规。

例如为了保障**首屏内容**的最快显示，通常会提到渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。

### 浏览器渲染页面的过程

从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：

1. DNS查询
2. TCP连接
3.  HTTP请求及响应
4. 服务器响应
5. 客户端渲染

所以浏览器渲染机制讨论的就是第五部分，即浏览器对内容的渲染，这一部分又可以分为5个部分：

1. 处理HTML标记并构建DOM树
2. 处理CSS标记并构建CSSOM树
3. 将DOM树和CSSOM树合并成一个渲染树
4. 根据渲染树来布局，以计算每个节点的几何信息
5. 将各个节点绘制到屏幕上

需要明白的是，这五部并不一定一次性按顺序完成，如果DOM树或CSSOM树被修改，以上过程需要重复执行，这样才能计算出哪些元素需要在屏幕上进行重新渲染。然而在实际页面中，CSS和JavaScript往往会多次修改CSSOM树和DOM树。下面就具体看看这几步是怎么实现的：

**浏览器收到HTML文件并转换成DOM树**

当我们打开一个网页时，浏览器都会去请求对应的HTML文件。平时我们写代码都是以字符串的形式，但是计算机硬件是不理解这些字符串的，所以网络中传输的内容其实都是0和1这些字节数据。当浏览器接收到这些字节数据后，他会将这些字节数据转换成字符串，也就是我们写的代码。

当数据转换为字符串后，浏览器会先将这些字符串通过词法分析转换为标记，这一过程在词法分析中叫做**标记化**，简单来说，标记还是字符串，是构成代码的最小单位，这一过程会将代码拆分成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。

![new7p4.png](https://s2.ax1x.com/2019/09/05/new7p4.png)

当结束标记化后，这些标记会紧接着转换成**节点**，最后这些结点会根据节点之间的联系构成一颗DOM树。

![ne03Bq.png](https://s2.ax1x.com/2019/09/05/ne03Bq.png)

以上就是浏览器从网络中接收到HTML文件然后一系列的转换过程

当然，在解析HTML文件的时候，浏览器还会遇到CSS和JS文件，这时候浏览器也回去下载并解析这些文件。

**将CSS文件转换为CSSOM树**

其实转换CSS到CSSOM树的过程和HTML转换DOM树的过程极其类似的

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归CSSOM树，然后确定具体的元素到底是什么样式。

如果你有点不理解为什么会消耗资源的话，可以看下面这个例子：

```html
<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
```

对于第一种设置样式来说，浏览器只需找到页面中所有的span标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的span标签，然后找到span标签上的a标签，最后找到div标签，然后给符合这种条件的span标签设置颜色，这样的递归过程很复杂，所以我们应该尽可能的避免写**过于具体**的CSS选择器，然后对于HTML来说也尽可能少的添加无意义的标签，保证层级扁平。

**生成渲染树**

当我们生成DOM树和CSSOM树以后，就需要将这两棵树组合为渲染树。

![neDMmn.png](https://s2.ax1x.com/2019/09/05/neDMmn.png)

在这一过程中，不是简单的将两者合并就行了，渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是display：none的，那么就不会在渲染树中显示。

**根据渲染树来布局、绘制在屏幕上**

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用CPU绘制，合成图层，显示在屏幕上

### 为什么操作DOM慢

想必大家都听说过操作DOM性能很差，但是这其中的原因是什么呢？

因为DOM是属于渲染引擎中的东西，而JS属于JS引擎中的东西。当我们通过JS操作DOM的时候，其实这个操作涉及了两个线程之间的通信，那么势必会带来一些性能上的损耗、操作DOM次数一多，也就等同于一直在进行线程之间的通信，并且操作DOM可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

### 经典面试题：插入几万个DOM，如何实现页面不卡顿？

对于这道题来说，首先我们肯定不能一次性把几万个DOM全部插入，这样肯定会造成卡顿，所以解决的重点用该是分批次部分渲染DOM。

1. 通过requestAnimationFrame的方式区循环插入DOM

这个方法应该大部分人都会想到，requestAnimationFrame来实现定时分批渲染，每16ms刷新一次

2. 虚拟滚动

这种技术的原理是只渲染可视区域的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

### 阻塞渲染：CSS和JavaScript

在谈论阻塞的时候，我们要清楚，现代浏览器总是并行加载资源的，例如当HTML解析器被脚本阻塞时，解析器虽然会停止构建DOM，但仍会识别该脚本后面的资源，并进行预加载。

同时，由于下面两点：

- 默认情况下CSS被视为阻塞渲染的资源，这意味这浏览器将不会渲染任何已处理的内容，直至CSSOM构建完成
- JavaScript不仅可以读取和修改DOM属性，还可以读取和修改CSSOM属性

存在阻塞的CSS资源时，浏览器会延迟JavaScript的执行和DOM的构建。

另外：

- 当浏览器遇到一个script标签时，DOM构建将暂停，直至脚本完成执行
- JavaScript可以查询和修改DOM和CSSOM
- CSSOM构建时，JavaScript执行将暂停，直至CSSOM就绪

所以script标签的位置很重要。实际使用时，可以遵循以下两个规则：

- CSS优先：引入顺序上，CSS资源先于JavaScript资源
- JavaScript应尽量少影响DOM的构建

**改变阻塞模式**

你可以通过给script标签加上defer或者async属性来改变之前所说的阻塞情形。

当script标签加上defer属性以后，表示JS文件会并行下载，但是会放到HTML解析完成后顺序执行，所以对于这种情况可以解决的是影响DOM的构建

对于没有任何依赖的JS文件可以加上async属性，表示JS文件下载和解析不会阻塞渲染。

### 重绘和回流

重绘和回流会在我们设置节点样式时频繁的出现，同时也会很大程度上影响性能。

- 重绘是当节点需要更改外观而不会影响布局的，比如改变color就称为重绘
- 回流是布局或者集合属性需要改变就称为回流

回流必定会发生重绘，但是重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

以下几个动作可能会导致性能问题：

- 改变window大小
- 改变字体
- 文字改变
- 添加或删除样式
- 定位或者浮动
- 盒模型

并且很多人不知道的是，重绘和回流其实也和Event Loop有关。当Event Loop执行完微队列后，会判断document是否需要更新。

### 减少重绘和回流

- 使用transform代替top
- 使用visibility代替display：none，因为前者只会引起重绘，后者会引发回流
- 不要把节点的属性值放在一个循环里面当成循环里的变量
- 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局
- 动画实现的速度选择。动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame
- CSS选择符从右往左匹配查找，避免节点层过多
- 将频繁重绘或者节流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点

通过以下几个常用属性可以生成新图层：

- will-change
- position：fixed
- video、iframe

### DOMContentLoaded和Load

你知道怎么测量到底有没有加快渲染速度呢？

![nevWWV.png](https://s2.ax1x.com/2019/09/05/nevWWV.png)

上面图片中有DOMContentLoaded事件，提早这个事件，也就加快了渲染速度。

**DOMContentLoaded和Load有什么区别呢？**

DOMContentLoaded顾名思义，就是DOM内容加载完毕。

那么什么是DOM内容加载完毕呢？

我们从打开一个网页说起，当输入一个url，页面的展示首先是空白的，然后过一会，页面会展示出内容，但是页面的有些资源比如说图片资源还无法看到，此时页面可以正常的交互，过一段时间后，图片才完成显示在页面，从空白页面到展示出页面内容，会触发DOMContentLoaded事件，而这段时间就是HTML文档被加载和解析完成。

明确DOMContentLoaded所计算的时间：

- 当文档中没有脚本的时候，浏览器解析完文档便能触发DOMContentLoaded事件
- 如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等待在其前面的css加载完成才能执行

在任何情况下DOMContentLoaded的触发不需要等待图片等其他资源加载完成

Load：页面上的所有资源（图片、音频、视频等）被加载完成以后才会触发Load事件，简单来说，Load事件会在DOMContentLoaded被触发后才会触发。

### 回答这个问题：我们为什么一再强调将css放在头部，将js文件放在尾部

在面试中，经常会有人回答页面的优化中提到将js放在body标签底部，原因是因为浏览器生成DOM树的时候，是一行一行读HTML代码的，script标签会阻塞DOM的构建，放在会后不会影响前面的页面的渲染，那么问题来了，既然DOM树完全生成好后页面才能渲染出来，浏览器有必须读完全部HTML才能生成完整的DOM树，那么script标签不放在body底部是不是也一样，因为DOM树的生成需要整个文档解析完毕。

![nmCEqO.png](https://s2.ax1x.com/2019/09/05/nmCEqO.png)

我们再来看一下页面渲染的过程，绿色标志线是First Paint的时间纳尼，为什么会出现First Pain，页面的paint不是在渲染树生成之后吗？

其实现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示内容，他不会等到所有的HTML解析，在这之前就已经开始构建和布局渲染树了。部分的内容将会被解析和显示。也就是说浏览器能够渲染不完整的DOM树和CSSOM树，尽快的减少白屏的时间。但是如果我们将js文件放在header中，js将阻塞解析DOM，DOM的内容会影响First Pain，导致First Pain延后。所以说我们会将js放在最后，以减少First Pain时间，但是不会减少DOMContentLoaded被触发的时间。

所以说这才是完整的回答。