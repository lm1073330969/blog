> 注意：该知识点属于性能优化领域，并且下面介绍的所有知识都是一个面试题

对于一个数据请求来说，可以分为发起网络请求，后端处理，浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。

比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端的一致，那么就没有必要再将数据传回来了，这样就能减少了浏览器的响应。

接下来的内容我们将通过几个部分来探讨浏览器缓存机制:

- 缓存位置
- 缓存策略
- 实际场景应用缓存策略

### 缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候才回去发起网络请求：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache
5. 网络请求

#### Service Worker

Service Worker是运行在浏览器背后的独立线程，一般可以用来实现缓存功能，使用Service Worker的话，传输协议必须是**HTTPS**，因为Service Worker中涉及到请求拦截，所以必须用HTTPS协议来保障安全。

**Service Worker的缓存和浏览器的其他内建缓存机制不同，他可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存、并且缓存是持续性的。**

Service Worker实现缓存功能一般分为三个步骤：首先需要先注册Service Worker，然后监听到install事件以后就可以缓存文件了，在下次用户访问的时候可以通过拦截请求的方式查询是否在缓存中有这个文件，如果有的话就可以直接使用，没有的话再去请求数据。

不管我们是从Memory Cache中还是网络请求中获取数据，浏览器都会显示我们是从Service Worker中读取的内容。

#### Memory Cache

Memory Cache也就是内存中的缓存，读取内存中的数据肯定比硬盘要快。**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。** 一旦我们关闭Tab页面，内存中的缓存也就被释放了。

当我们访问过页面之后，再次刷新页面，可以发现很多数据都来自内存缓存：

![nSUWdK.png](https://s2.ax1x.com/2019/09/01/nSUWdK.png)

**既然内存缓存这么高效，我们是不是能让数据都存在内存中呢？**

这是**不肯能**的。首先计算机的内存比硬盘的容量小很多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中去试可以存储大部分文件，比如JS、HTML、CSS、图片等。但是浏览器会把哪些文件丢进内存中，这个过程就很玄学了，我看到有资料这样写：

- 对于大文件来说，大概率是不存在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存进硬盘

#### Disk Cache

Disk Cache也就是存储在硬盘中缓存，读取速度慢点，但是什么都能存储到磁盘中，和Memory Cache比**胜在容量和存储时效性上面**。

在所有浏览器缓存中，Disk Cache覆盖面基本是最大的，他会根据HTTP Header中的字段判断哪些资源需要缓存，哪些资源可以不用请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘保存下来，就不会再次去请求数据。

### Push Cache

Push Cache（推送缓存）是在HTTP2中的内容，当以上三种缓存都没有命中的时候，他才会被使用，**并且缓存事件也很短暂，只会在会话中存在，一旦会话结束就被释放**

总结：

- 所有的资源都能被推送，但是Edge和Safari浏览器兼容性不怎么好
- 可以推送no-cache和no-store的资源
- 一旦连接被关闭，推送缓存就被释放
- 多个页面可以使用相同的HTTP2连接，也就是说能使用同样的缓存
- Push Cache中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 可以给其他域名推送资源

如果以上四种缓存都没有命中的话，只能发起**网络请求**来获取资源了

为了性能上的考虑，大部分的接口都应该选择好缓存策略。

### 缓存策略

通常浏览器缓存策略分为两种：

- 强缓存
- 协商缓存

并且缓存策略可以通过设置HTTP Header来实现。

#### 强缓存

强缓存可以通过设置两种HTTP Header实现：

- Expires
- Cache-Control

强缓存表示在缓存期间不需要发送请求。

**Expires**

> Expires：Wed, 22 Oct 2018 08:41:00 GMT

Expires的值是服务端返回的过期时间，Expires是HTTP1.0的产物。他有一个问题，就是**受限于本地时间**，如果修改了本地时间，可能会造成缓存失效。

不过现在基本的浏览器默认的优势HTTP1.1，所以他的作用基本可以忽略。

**Cache-Control**

> Cache-Control：max-age=30

Cache-Control出现于HTTP1.1，优先级高于Expires。该属性值表示资源会在30秒之后过期，需要再次请求。

Cache-Control**可以在请求头或者响应头中设置**，并且可以组合使用多种指令。常见有public、private、max-age、no-cache、no-store。**默认是private缓存**


指令 | 作用
---|---
public | 表示响应可以被客户端和代理服务器缓存
private | 表示响应只能被客户端缓存
max-age = 30 | 缓存30秒后过期失效
no-cache | 资源被缓存，但是立即失效，下次会发起请求验证资源是够过期（也就是需要使用协商缓存来验证缓存数据）
no-store | 所有内容都不会缓存，强制缓存和协商缓存都不会被触发

#### 协商缓存

当浏览器发起请求验证资源时，如果资源没有改变，那么服务端就会返回304状态码，可以直接使用资源，并且更新浏览器缓存有效期

如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种HTTP Header实现：

- Last-Modified
- ETag

**Last-Modified/If-Modified-Since**

Last-Modified表示本地文件最后的修改日期，If-Modified-Since会将Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，如果有更新的话就会将新的资源发送过来，否则返回304

但是Last-Modified存在一些弊端：

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成Last-Modified被修改，服务端认为缓存被修改过，所以导致发送相同的资源
- 因为Last-Modified只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务器会认为资源没有被修改过，不会返回正确的资源

因为以上这些弊端，所以在HTTP1.1出现了ETag

**ETag/If-None-Match**

**ETag是服务器响应请求时，返回当前文件的一个唯一标识（由服务器生成），只要资源有变化ETag就会重新生成。** 

浏览器在下一次加载资源向服务器发送请求时，会将上一次ETag的值放到If-None-Match里，服务器只需要比较客户端传来的If-None-Match与自己服务器上的ETag是否一致。如果有变动会将新的资源发送回来，则直接返回 304 知会客户端直接使用本地缓存即可。

**两者之间的比较**

- 首先在精确度上，ETag要优于Last-Modified，Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是ETag每次都会改变，确保了准确度。
- 如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致
- 第二在性能上，ETag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而ETag需要服务器通过算法来计算出一个hash值
- 第三在优先级上，服务器校验优先考虑 Etag。


### 缓存机制

两种缓存规则的不同：

- 强缓存优先于协商缓存
- 如果强缓存生效直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存

以上就是缓存策略的所有内容了，看到这里，不知你是否存在这样一个疑问。**如果什么缓存策略都没设置，那么浏览器会怎么处理？**

对于这种情况，浏览器会采用一个启发式算法，通常会取响应头中的Data减去Last-Modified值的10%作为缓存时间。

### 实际场景应用缓存策略

#### 频繁变动的资源

对于频繁变动的资源，首先需要使用**Cache-Control:no-cache**使浏览器每次都请求服务器，然后配合ETag或Last-Modified来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小

#### 代码文件

这里特指除了HTML代码文件，因为HTML文件一般不缓存或者缓存时间很短。

一般来说，现在都适用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们可以给代码文件设置缓存有效期一年，这样只有当HTML文件中引入的文件名发生了改变才会去下载最新的代码文件，否则一直使用缓存。