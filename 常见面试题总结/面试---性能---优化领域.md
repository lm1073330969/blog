### 图片加载优化

1. 不用图片。很多时候会使用到很多的修饰类图片，其实这类修饰图片完全可以用CSS去代替
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都可以用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片
3. 小图使用base64格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 对于能够显示webP格式的浏览器尽量用webP格式，因为webP格式具有更好的图像压缩算法，能带来更小的图片体积，而且肉眼识别无差异的图像质量
6. 小图用png
7. 图标尽量用svg
8. 照片使用JPEG

### DNS预解析

DNS将域名和IP地址相互映射的一个分布式数据库

DNS预读取是一项使浏览器主动去执行域名解析的功能，他的范围包括文档的所有链接，无论是图片的、CSS的、JavaScript等其他用户能够点击的URL，减少用户点击时的延迟

当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的IP地址

作用：根据浏览器定义的规则，提前解析之后可能会用到的域名，将解析结果缓存到系统缓存中，缩短DNS解析时间，开提高网站的访问速度

```html
<link rel="dns-prefetch" href="http://www.google.com">
```

### 预加载

在开发中可能会遇到这样的情况，有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载

预加载是强制浏览器请求资源，并且不会阻塞onload事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://www.google.com">
```

预加载可以在一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好

### 预渲染

通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启：

```html
<link rel="prerender" href="http://www.google.com">
```

预渲染是指：无需使用微博服务器实时动态编译HTML，而是在构建就生成静态HTML文件，优点是设置预渲染简单，并且可以将我们的前端作为一个完全静态的站点。我们如果使用webpack，可以使用插件prerender-spa-plugin轻松地添加预渲染

**服务端渲染ssr**

在目前spa应用中，首页嵌入后端工程，数据通过接口获得，异步的ajax请求会导致数据滞后，而ssr优势入下：

- 页面直出，方便SEO
- 更快的内容到达时间，特别是对于缓慢的网络情况，或运行缓慢的设备，无需等待所有的JavaScript都下载并执行，才显示服务器渲染的标记，所以用户会更快速的看到完整渲染的页面。通常可以产生更好的用户体验。

### 懒执行

懒执行就是将某些逻辑延迟到使用的时候在计算。该技术可以用于首屏优化。对于某些耗时逻辑并不需要在首屏就是用的，可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或事件调用来唤醒

### 懒加载

懒加载就是将不关键的资源延后加载

懒加载的原理只加载自定义区域（通常是可视区，但也可以是即将进入可视区域）内需要加载的东西。

图片懒加载：先设置图片标签src属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为src属性

懒加载不仅可以用于图片，比如进入可视区域才开始播放视频等等

### CDN

我们通常将静态资源使用CDN加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个CDN域名。并且对于CDN加载静态资源需要注意CDN域名要与主站不同，否则每次请求都会带上主站的cookie，平白消耗流量

### 节流和防抖

**节流和防抖的区别**

节流和防抖的作用都是防止函数多次调用

区别在于，假设一个用户一直在触发这个函数，且每次触发函数的时间间隔小于设置的时间，防抖情况下只会调用一次，节流的情况下会每隔一定时间就调用一次函数

**节流**

一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动中一直发起请求，而是隔一段时间发起一次。这种情况就属于节流

```js
let canRequest = true;

document.getElementById('page').onscroll = function() {
    if(!canRequest) {
        return;
    }

    canRequest = false;
    setTimeout(() => {
        canRequest = true;
    }, 3000)
}
```

节流实现的要点：

- 声明一个变量，记录当前代码是否在执行
- 如果空闲，就可以正常执行
- 如果正在执行，则取消这次方法，直接return

**防抖**

考虑一个场景，如果有一个按钮点击会触发网络请求，但是我们并不希望每次点击都能发送网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才会去发起网络请求，对于这种情况可以使用防抖

```js
let timer = null;

document.getElementById('button').onclick = function() {
    clearTimeout(timer);
    timer = setTimeout(() => {
        console.log('可以点击发送请求');
    }, 3000)
}
```

防抖的原理，通过闭包保存一个setTimeout返回值，每当用户点击的时候就会把前一个setTimeout清除掉，然后又会创建一个新的setTimeout，这样就能保证点击按钮之后的3秒钟内还有点击操作的话就不会执行要执行的操作了。

其实函数节流与函数防抖的原理非常简单，巧妙地使用setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。