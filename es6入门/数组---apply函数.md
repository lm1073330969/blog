# 数组---apply函数

## 语法

```
fun.apply(thisArg, [argsArray]);
```

thisArg：参数是可选的，在fun函数运行时使用的this值。如果这个函数处于非严格模式下，则指定为null或undefined时会自动替换为指向全局对象，原始值会被包装。

argsArray：参数是可选的，一个==数组==或==类数组对象==，其中的数组元素将 ==作为单独的参数(也就是将数组参数进行了参数序列)传给fun函数.== 如果该参数的值为null或undefined，则表示不需要传入任何参数。

**注意：** call方法和apply方法类似，区别就是call方法接受的是参数列表，而apply方法接受的是一个参数数组。

## 描述

apply函数使用的例子：

```
let obj = {
  username: 'lee'
};

function fun(number) {
  console.log(`学生姓名：${this.username}；学号：${number}`);    //学生姓名：lee；学号：000001
}
//apply调用
fun.apply(obj, ['000001']);
//call调用
fun.call(obj, '000001');
```

apply函数和call函数非常相似，根据上面的例子我们也能看出，两者输出的结果是一样的，唯一的差别就是在第二个参数的传递的格式。apply函数的第二个参数是需要将要传送的值放在一个数组里面。apply会自动将数组参数变为序列参数；call函数的参数则是参数列表，所传递的参数必须一一列举出来，并且从第二个参数往后一直可以增加。

其实通过上面的解释两者的第二个参数传递的差别，我们也能想到一个问题，就是apply函数的参数既可以是数组也可以是类数组，那么是不是可以传递arguments，在不知道参数传递的具体的个数时，apply也是可以接受的，这点想的没有错。因为官方文档上也有这么一句话，就是：使用apply函数的时候可以不需要知道被调用的所有参数。

但是call就不行，必须将传递的参数一一列出来。

文档还说了，从ES5开始，可以使用任何种类的类数组对象，就是说只要有一个length属性和length的值为（0...length-1）范围之内的整数。比如：

```
let likeArray = {
  '0': '张三',
  '1': '李四',
  '2': '王五',
  length: 3
}
```

## 示例

### 用apply将数组添加到另一个数组

我们可以用push将元素追加到数组中，并且，因为push接收可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加数组里面的元素，因此，我们最终会是一个二维数组，但这不是我想要的形式，我想要的形式是将数组里面的元素添加进去。

由于想要的形式的局限，concat能得到我想要的形式，但是concat并不是附加到原有的数组，而是创建并返回一个新数组。但是我想要的是附加到现有的数组中，那怎么办呢？写一个循环，这是第一个被我放弃的想法。

看完上面的apply的描述，apply还有一个特性就是会将数组变成参数序列，那是不是说明，数组的内容解析成了一个个的，可以用push将他们放进数组中，这样就不会形成二维数组。

看下面这个例子：

```
let array = [1, 2, 3];
let elements = [4, 5, 6];
array.push.apply(array, elements)
console.log(array);     //[1, 2, 3, 4, 5, 6]
```

### 使用apply和内置函数

聪明的apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。在接下来的例子中我们会使用Math.max/Math.min来找出一个数组中的最大值/最小值。

```
let array = [1, 2, 3, 4, 5];

console.log(Math.max.apply(null, array));   //5   基本等同于Math.max(array[0],...);
    
console.log(Math.min.apply(null, array));   //1   基本等同于Math.min(array[0],...);
```

