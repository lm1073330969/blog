# ES6入门---函数的扩展

## 函数参数的默认值

### ES5自己写的默认值

在ES5中是不能直接在为函数添加默认值的，所以通常我们会在程序中进行判断传过来的参数是否存在来决定使用传过来的参数，还是用默认的。

但是自己判断有些情况，得不到想要的结果。

比如：下面的例子，是判断传过来的值是否为true来进行默认值的赋值的。

```
function morenzhi(a, b) {
    a = a ? a : 'hello';
    return `${a} ${b}`;
}

console.log(morenzhi('hello', 'world'));        //hello world
console.log(morenzhi('hello'));                 //hello undefined
//这种情况判断就没有得到我们想要的结果，因为我们传了一个空字符串的值，得到的却是默认值，是因为在判断的时候，空字符串被转换成了false，所以使用了默认的值。
console.log(morenzhi('', 'world'));             //hello world
```

后来为了解决这个问题，需要判断一下传过来的参数的类型，只要不是undefined就不赋给默认值。

改善后的代码：

```
function morenzhi(a, b) {
    if(typeof a == 'undefined') {
        a = 'hello'
    }
    return `${a} ${b}`;
}

console.log(morenzhi('hello', 'world'));        //hello world
console.log(morenzhi('hello'));                 //hello undefined
//这次结果就是我想要的了
console.log(morenzhi('', 'world'));             // world
```

由于这种需求，ES6为了统一将函数的参数的默认值写进了标准。

### ES6的函数默认值

ES6函数的默认值，只需要写在参数的后面，如果传过来的参数不是完全为undefined是不会赋给参数默认值的。

同样的例子，我们看ES6的写法：

```
function morenzhi(a, b = 'world') {
    return `${a} ${b}`;
}

console.log(morenzhi('hello', 'world'));        //hello world
console.log(morenzhi('hello'));                 //hello world
console.log(morenzhi('hello', ''));             //hello
```

比用ES5的写法简便了许多。

函数中使用默认值参数，是默认声明的，函数体内不能再次声明，不能用let和const再次声明，会报错

```
function morenzhi(a = 5, b = 3) {
    let a = 1;                  //报错：Identifier 'a' has already been declared
}
```

如果不使用默认参数，函数中有同名变量不会报错，要是使用默认参数的情况下，参数中有默认参数会报错：

```
//没有报错
function morenzhi(a, b, b) {
    //。。。
}

//报错
function ES6fun(a, b = 2, b) {
    //....
}
```

还有一个容易忽略的点就是，参数的默认值不是传值的，而是每次都会进行重新计算默认值的表达式。

### 函数的默认值和解构赋值默认值相结合

上面的例子中只有函数的默认值。

接下来看一个只有解构赋值默认值的例子：

1. 正常的传值，传入一个对象

```
function fun({a, b = 2}) {
    console.log('a = ', a);
    console.log('b = ', b);
}

fun({a: 1, b: 3});      //a =  1;   b =  3
```

2. 当只传入对象中的一个值或不传值，但是会传一个空对象，时的情况

```
fun({});        //a =  undefined;   b =  2
fun({a: 2});       //a =  2;   b =  2
```

3. 但是要是什么都不传，就是调用函数的情况，程序就会报错，因为函数的默认值参数只有解构赋值的默认值，没有给函数的参数默认值。

```
fun();      //Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.
```

要是想解决像第三种情况，什么都不传也不报错，同时也有相应的默认值。

就需要将默认值和解构赋值默认值相结合：

```
function fun({a, b = 2} = {}) {
    console.log('a = ', a);
    console.log('b = ', b);
}

fun();      //a =  undefined;   b =  2
```

上面的例子也没有报错，并且有默认值的输出的还是默认值，这就是默认值和解构默认值相结合的好处。

### Q1：练习题，请问下面两种写法有什么差别？

> 写法一：

```
function fun1({x = 0, y = 0} = {}) {
    return [x,y];
}
```

> 写法二：

```
function fun2({x, y} = {x: 0, y: 0}) {
    return [x,y]
}
```

上面两种函数写法的区别：

（1）当什么都不传入的时候，只是调用函数是，两者的返回值没有区别：

```
console.log(fun1());        //[0,0]
console.log(fun2());        //[0,0]
```

（2）当两者都传入完整的值时，两种函数也没有区别：

```
console.log(fun1({x: 1, y: 1}));        //[1, 1]
console.log(fun2({x: 1, y: 1}));        //[1, 1]
```

（3）当只传入对象中的其中一个值的时候两者就有了区别：  
写法一：会将正常传入的x值输出，没有传入y值，但是y值有默认值，所以y等于默认值0.   
写法二：虽说也有默认值，但是他没有解构的默认值，当传入其中一个值的时候，他的函数默认值就会被传进来的参数覆盖掉，但是传进来的参数又不是完整的能解构的对象，所以没有找到相对应的参数只能是undefined。方法二的函数里面的操作相当于：{x, y} = {x: 1};
这样的对象解构出来y就是undefined。

```
console.log(fun1({x: 1}));        //[1, 0]
console.log(fun2({x: 1}));        //[1, undefined]
```

### 参数默认值的位置

通常情况下，定义了默认的参数，应该是函数的尾参数，因为这样比较容易看出来省略的是哪些参数，如果不是尾参数设置了默认值，南无起不到参数省略的作用的。

1. 默认的参数不是尾参数的例子，起不到省略参数的作用：

```
function fun(a = 1, b, c) {
  return [a, b, c];
}

console.log(fun());     //[1, undefined, undefined]
console.log(fun(2, 3)); //[2, 3, undefined]
console.log(, 2, 3)     //报错
```

2. 还有一种情况，就是只有是显示的传入的值为undefined才会使用默认值，注意只有undefined才能，null不能。

```
function fun(a = 1, b, c) {
  return [a, b, c];
}

console.log(fun(undefined, 2, 3));      //[1, 2, 3]
console.log(fun(null, 2, 3));           //[null, 2, 3]
```

### 函数的length

length属性的含义是，该函数预期传入的参数个数，如果某个参数指定了默认值以后，预期传入的参数的个数就不包括这个参数了，rest参数也不会计入length属性。

1. 如果参数里面有默认值，那么length的值就是参数的个数减去默认值的个数。

```
console.log(function() {}.length);      //0
console.log(function(a) {}.length);     //1
//因为函数只有一个参数，但是这个参数又有默认值，所以length = 1 - 1 = 0
console.log(function(a = 1) {}.length);     //0
//函数有三个参数，有一个有默认值，所以函数的参数为2
console.log(function(a, b, c = 3) {}.length);
```

2. 有一个问题需要注意，就是有默认参数的要放在参数的末尾，即尾参数，否则这个默认参数后面没有默认值的参数不会计入参数的个数。看下面的例子：

```
console.log(function(a = 1, b, c) {}.length);       //0
console.log(function(a, b = 2, c) {}.length);       //1
console.log(function(a, b, c = 3) {}.length);       //2
```

注意：rest参数必须是最后一个参数，否则会报错。

### 作用域

一旦设置了参数的默认值，函数进行生命初始化时，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失。这种语法行为在不设置参数默认值时是不会出现的。

1. 下面这个例子中，参数y的默认值就是变量x的值。

```
function fun(x, y = x) {
    console.log(y);         //2
}

fun(2);
```

在函数进行调用的时候，参数会形成一个单独的作用域，在这个作用域里面相当于一下的操作赋值。所以最后输出的结果是参数x传进来的值。

```
let x = 2;
let y = x;
```

2. 再看下面这两种情况的对比，要注意这个地方很容易混淆，最好自己敲着理解，光看定义你可能觉得明白了，但是不实践可能是一种会的假象，只有自己敲出结果试着说明：

```
//第一种
let x = 1;
function fun(y = x) {
    console.log(y);         //1
}

fun();

//第二种
var x = 1;
function fun(x) {
    console.log(x);         //undefined
}

fun();
```

调用函数时没有赋值，参数形成的作用域中没有变量x，所以会向上一个作用域中找，找到的x=1，所以最后输出的结果为1.要是没有在全局定义x，就会找不到，就会报错。

这两种的区别就在于：

第一种有默认值，在调用的时候参数会产生一个单独的作用域，操作相当于let y = x;当前作用域没有就会去上一级查找，在全局作用域中找到了x的值，并赋给y，所以y就有值了。  

第二种没有默认值，在调用的时候不会形成单独的作用域，所以在函数中没有传参，就是找不到x，也不会去上级作用域中去查找，没传就是undefined。

这两个区别有利于对下面的练习题的解决。

### Q2：练习题，看下面两端代码输出的结果，并简单解释一下。

> 第一段：

```
var x = 1;
function fun1(x, y = function() { x = 2 }) {
    var x = 3;
    y();
    console.log(x); 
}

fun1();          
console.log(x);
```

> 第二段：

```
var x = 1;
function fun2(x, y = function() { x = 2 }) {
    x = 3;
    y();
    console.log(x);
}

fun2();
console.log(x);
```

**A**：让我们一步步分析这两段代码

**分析第一段代码**

接下来让我们分析一下第一段代码：

第一步：因为y有默认值的原因，参数会形成一个单独的作用域，因为y默认赋值的是一个函数，这个函数里面用到了变量y。所以这个作用域里面的声明相当于以下：

```
let x;
let y = function() {
    x = 2;
}
```

注意：这个初始化结束后，这个作用域就会自动消失。并且这个匿名函数内的变量x指向的是参数作用域中x的值。

第二步：调用的函数体里面又有var x = 3;这个是在函数体的作用域内进行声明了一个内部变量。和初始化时候的参数作用域内x不是同一个变量。是因为在函数体内重新进行声明了，要是没有声明就会是同一个。

看下面的例子输出的结果：

```
var x = 1
function fun1(x,y = function() {
    x = 2;
    console.log(x);     //2
  }) {
  var x = 3
  y()
  console.log(x)        //3
}

fun1()
console.log(x) //1
```

第三步：接下来执行y函数，因为调用的时候什么都没有传，所以y会执行他的默认值，将参数作用域里面的x的值赋为2。

第四步：打印x变量值的语句。因为这个变量x在函数体作用域有一个，在参数声明变量形成的单独的作用域里面也有一个。这个打印语句，首先会在自己的当前作用域内找，就算是在执行y的时候，也有对x的赋值，但是那个x指向的是参数形成的作用域内。所以输出的不是2，是当前用var声明的x的值。打印全局变量x，值没有发生变化。

```
fun1();         //3       
console.log(x); //1
```

**分析第二段代码**

第一步和第一段代码是一样的。

第二步：就发生了变化，这次不是在函数体内声明一个变量x，而是赋值，因为在参数初始化之后，作用域就消失了，只是赋值，指向的和改变的值也都是同一个变量。所以在x = 3语句执行完后，x的值变成了3。

第三步：调用y函数。x的值变为了2

第四步打印：打印x的值，在函数体的作用域里面找到的x，是执行完y函数之后赋给x的值。

所以最后的结果是：函数内的x的值为2，全局的x的值没有改变：

```
fun2();         //2      
console.log(x); //1
```

## rest参数

ES6引入了rest参数，用于获取函数的多余参数，这样就不需要使用arguments对象了。

### rest参数和arguments对象的区别

因为arguments对象是一个类数组，想要使用的时候必须将类数组转换为真正的数组，才能使用。

但是rest参数就不一样，它本身就是一个真正的数组，只是将多余的参数放在了数组中，使用的时候和数组的操作没有区别。

两者操作的区别：

```
function classArray(...rest) {
  //两者的打印出来的区别：arguments是类数组，rest打印出来就是真正的数组
  console.log(arguments);   //Arguments(3)[2, 3, 4, callee: (...), Symbol(Symbol.iterator): ƒ]
  console.log(rest);        //[2, 3, 4]

  //让我们验证一下，类数组不能操作数组相应的api，比如向数组里面添加一个数字5, 扩展运算符rest输出的是真正的数组，可以操作相应的api
  //arguments
  // arguments.push(5);    //报错：arguments.push is not a function
  //rest
  rest.push(5);         
  console.log(rest);       //[2, 3, 4, 5]
}

classArray(2, 3, 4);
```

注意：rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。

函数的参数的length属性也不包括rest参数。

## name属性

函数有一个name属性，返回的是该函数的函数名。

**ES5中name属性**

在ES5中，如果将一个匿名函数赋值给一个变量，会返回一个空的字符串。

```
var fun = function() {}

fun.name;       //""
```

**ES6中的name属性**

在ES6中，如果将一个匿名函数赋值给一个变量，会返回那个变量的名字，相当于变量等于一个匿名函数。

```
let fun = function() {}

fun.name;       //"fun"
```

如果将一个有名的函数赋值给一个变量，那么两者没有区别，返回的都是函数本来的名字。

```
let fun = function box() {}

fun.name;       //'box'
```

## 箭头函数

箭头函数的用法明显的就是减少代码的行数减少，看起来更加简洁明了。一般的用法我已经了解。

但是，在使用箭头函数的时候需要注意以下几点：

1. 函数体内的this对象，就是定义时候的对象，而不是使用时所在的对象。
2. 不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
3. 箭头函数中，不可以使用arguments对象，该对象在函数体内不存在。如果要用。可以用rest参数代替。
4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。

上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，this的指向是固定的。

注意：由于箭头函数没有自己的this，所以当然也就不能用call、apply、bind这些方法去改变this的指向。

## 尾调用

尾调用之所以与其他调用不同，就在于他的特殊的调用位置。

我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”，用来保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用了函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

如果所有的函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是尾调用优化的意义。

注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则无法进行“尾调用优化”。

## 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归：递归非诚耗费内存，因为需要同时保存成百上千个调用帧，很容易发生“栈溢出”错误。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

运用尾递归的两个例子：

**阶乘函数**

- 不使用尾递归

```
//不使用尾递归
function factorial(n) {
  if(n <= 1) {
    return 1;
  }

  return  n * factorial(n-1);
}

console.log(factorial(100));     //9.33262154439441e+157
```

- 使用尾递归

```
function factorial(n, total = 1) {
  if(n <= 1) {
    return total;
  }

  return factorial(n - 1, n * total);
}

console.log(factorial(100));     //9.33262154439441e+157
```

上面函数阶乘的例子中，无论有没有使用尾递归都没有发生栈溢出的现象，从结果上面看两者的情况没有什么差别。但是使用尾递归的调用记录的复杂度为O(1),没有使用尾递归的调用的记录复杂度为O(n)；

**斐波那契数列**

**背景**

假定你有一雌一雄一对刚出生的兔子，他们在长到一个月大小时开始交配，在第二月结束时，䧳兔子产下另一对兔子，过了一个月后他们也开始繁殖，如此这般持续下去。每只䧳兔在开始繁殖时每月都产下一对兔子，假定没有兔子死亡，在一年后总共会有多少对兔子？

在一月底，最初的一对兔子交配，但是还只有1对兔子；在二月底，䧳兔产下一对兔子，共有2对兔子；在三月底，最老的䧳兔产下第二对兔子，共有3对兔子；在四月底。最老的䧳兔产下第三对兔子，两个月前生的䧳兔产下一对兔子，共有5对兔子；......如此这般计算下去，兔子对数分别是：1,1,2,3,5,8,13,21,34,55,89,144...看出规律了吗？从第3个数目开始，每个数目都是前两个数目之和。这就是著名的斐波那契数列。

- 不使用尾递归

在不使用尾递归的例子中，参数为100时超时了。

```
//不使用尾递归
function fib(n) {
  if(n <= 2) {
      return 1;
  }

  return fib(n - 1) + fib(n - 2);
}

console.log(fib(10));     //55
console.log(fib(100));    //超时
```

- 使用尾递归

使用尾递归的例子可以看出，没有超时，这是因为ES6中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对来说节省内存。

```
//使用尾递归
function fib(n, ac1 = 1, ac2 = 1) {
  if(n <= 2) {
    return ac2;
  }

  return fib(n-1, ac2, ac1 + ac2);
}

console.log(fib(10));     //55
console.log(fib(100));    //354224848179262000000
```

## 递归函数改写成尾递归

将递归函数改写成尾递归函数，需要确保最后一步调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。还需要一个中间变量来存储最后输出的结果，比如上面的两个例子，都有一个中间变量来存储结果。

为了保证和不使用尾递归函数保持一致，传的参数不变，就需要和ES6的函数参数默认值相结合。

















